{
	"title":"Truncate数据表背后的几个参数",
	"updateTime":"2018-04-24 00:20:31",
	"content":"Truncate语句是Oracle SQL体系中非常有特色的一个。Truncate直接的效果是进行数据表数据的清理，深层次是一种典型的DDL语句。\r\n\r\n\r\nOracle中，delete语句是一种标注动作。在执行过程中，数据库会访问每个符合删除条件的数据行进行标注动作，标记为“已删除”。删除的数据范围越大、执行路径越长，执行SQL语句时间也就越长。所以说，delete操作是一个和数据规模成正比的执行过程。\r\n\r\n而Truncate操作最多接触的知识点是DDL本质。Truncate操作下，Oracle并不关注每个数据行和数据范围，而是集中修改段头结构、更新核心数据字典上。对于特别巨大的数据表，Truncate操作速度要显著快于delete操作。\r\n\r\n在11.2.0.x系列版本中，我们还有一些参数可以用来控制Truncate数据表的行为。具体包括：drop storage、drop all storage和reuse storage，每个选项对应truncate数据表的不同行为。本文集中介绍参数的几个选项。\r\n\r\n1、环境介绍\r\n\r\n笔者使用Oracle 11gR2进行测试，版本是11.2.0.4。\r\n\r\nSQL\u003e select * from v$version;\r\n\r\nBANNER\r\n\r\n--------------------------------------------------------------------------------\r\n\r\nOracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production\r\n\r\nPL/SQL Release 11.2.0.4.0 - Production\r\n\r\nCORE  11.2.0.4.0    Production\r\n\r\nTNS for 64-bit Windows: Version 11.2.0.4.0 - Production\r\n\r\nNLSRTL Version 11.2.0.4.0 – Production\r\n\r\n创建专门的非sys用户，注意：这个细节很重要。\r\n\r\nSQL\u003e create user test identified by test;\r\n\r\nUser created\r\n\r\n \r\n\r\nSQL\u003e grant connect, resource to test;\r\n\r\nGrant succeeded\r\n\r\n \r\n\r\nSQL\u003e grant select_catalog_role to test;\r\n\r\nGrant succeeded\r\n\r\n \r\n\r\nSQL\u003e grant select any dictionary to test;\r\n\r\nGrant succeeded\r\n\r\n \r\n\r\n \r\n\r\n登录实验环境，创建数据表。\r\n\r\nSQL\u003e conn test/test@sicsdb\r\n\r\nConnected to Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 \r\n\r\nConnected as test\r\n\r\n \r\n\r\nSQL\u003e show user\r\n\r\nUser is \"test\"\r\n\r\n \r\n\r\nSQL\u003e create table t as select * from dba_objects;\r\n\r\nTable created\r\n\r\n \r\n\r\nSQL\u003e create index idx_t_id on t(object_id);\r\n\r\nIndex created\r\n\r\n \r\n\r\nSQL\u003e exec dbms_stats.gather_table_stats(user,\u0027T\u0027,cascade \u003d\u003e true);\r\n\r\nPL/SQL procedure successfully completed\r\n\r\n对应数据段和索引段结构如下：\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027T\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28808      65536          8\r\n\r\n        1          4      28816      65536          8\r\n\r\n        2          4      28824      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        26          4      30336    1048576        128\r\n\r\n \r\n\r\n27 rows selected\r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027IDX_T_ID\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28936      65536          8\r\n\r\n        1          4      28944      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        15          4      30464      65536          8\r\n\r\n        16          4      30592    1048576        128\r\n\r\n \r\n\r\n17 rows selected\r\n\r\n2、Truncate drop storage行为\r\n\r\nTruncate数据表默认行为包括了drop storage参数。使用drop storage之后，数据表中所有数据都被清空，数据表和索引段只保留一个分区结构。\r\n\r\nSQL\u003e truncate table t drop storage;\r\n\r\nTable truncated\r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027T\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28808      65536          8\r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027IDX_T_ID\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28936      65536          8\r\n\r\n \r\n\r\n \r\n\r\n注意：虽然两个段头分区extent的大小和起始段都没有发生变化，依然保持了28808和28936。但是数据字典结构中，认为是一个新的段结构。\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select object_name, object_id, data_object_id from dba_objects where owner\u003d\u0027TEST\u0027 and object_name in (\u0027T\u0027,\u0027IDX_T_ID\u0027);\r\n\r\n \r\n\r\nOBJECT_NAME      OBJECT_ID DATA_OBJECT_ID\r\n\r\n--------------- ---------- --------------\r\n\r\nIDX_T_ID            123667        123668\r\n\r\nT                  123666        123669\r\n\r\n \r\n\r\n \r\n\r\nT和IDX_T_ID的object_id和data_object_id不一致了。Data_object_id是内部段结构的编号信息。一旦进行truncate操作，就会认为是一个新段生成。\r\n\r\n默认truncate操作下，Oracle会删除所有数据，回收所有段结构后重新分配一个新的extent。内部的段结构上，Oracle认为是在原来段头位置上重新分配的新段。\r\n\r\n \r\n\r\n3、Truncate reuse storage行为\r\n\r\n \r\n\r\n下面来测试一下reuse storage参数行为。首先需要重建表数据内容和充实段结构。\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e insert into t select * from dba_objects;\r\n\r\n99693 rows inserted\r\n\r\n \r\n\r\nSQL\u003e commit;\r\n\r\nCommit complete\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027T\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28808      65536          8\r\n\r\n        1          4      28816      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        26          4      30720    1048576        128\r\n\r\n \r\n\r\n27 rows selected\r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027IDX_T_ID\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28936      65536          8\r\n\r\n        1          4      28840      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        17          4      30208    1048576        128\r\n\r\n \r\n\r\n18 rows selected\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n操作reuse storage。\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e truncate table t reuse storage;\r\n\r\n \r\n\r\nTable truncated\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027T\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28808      65536          8\r\n\r\n        1          4      28816      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        26          4      30720    1048576        128\r\n\r\n \r\n\r\n27 rows selected\r\n\r\n \r\n\r\nSQL\u003e select EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS from dba_extents where segment_name\u003d\u0027IDX_T_ID\u0027 and owner\u003d\u0027TEST\u0027;\r\n\r\n \r\n\r\n EXTENT_ID    FILE_ID  BLOCK_ID      BYTES    BLOCKS\r\n\r\n---------- ---------- ---------- ---------- ----------\r\n\r\n        0          4      28936      65536          8\r\n\r\n        1          4      28840      65536          8\r\n\r\n        2          4      28904      65536          8\r\n\r\n（篇幅原因，有省略……）\r\n\r\n        17          4      30208    1048576        128\r\n\r\n \r\n\r\n18 rows selected\r\n\r\n \r\n\r\n \r\n\r\n数据的确删除。\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select count(*) from t;\r\n\r\n \r\n\r\n  COUNT(*)\r\n\r\n----------\r\n\r\n        0\r\n\r\n \r\n\r\n \r\n\r\nReuse storage情况下，段结构没有回收，数据却被删除了！从段结构情况看，Oracle依然视之为新段，data_object_id发生变化。\r\n\r\n \r\n\r\n \r\n\r\nSQL\u003e select object_name, object_id, data_object_id from dba_objects where owner\u003d\u0027TEST\u0027 and object_name in (\u0027T\u0027,\u0027IDX_T_ID\u0027);\r\n\r\n \r\n\r\nOBJECT_NAME      OBJECT_ID DATA_OBJECT_ID\r\n\r\n--------------- ---------- --------------\r\n\r\nIDX_T_ID            123667        123670\r\n\r\nT                  123666        123671\r\n\r\n更多详情见请继续阅读下一页的精彩内容： http://www.linuxidc.com/Linux/2015-04/115921p2.htm\r\n\r\n\r\n来源： http://www.linuxidc.com/Linux/2015-04/115921.htm",
	"sort":1
}